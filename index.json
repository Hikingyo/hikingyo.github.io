[{"categories":["outils","CI/CD","qualité"],"contents":"De l’art de la review zen Combien d’heures se perdent en merge requests sur des broutilles ? Espaces en trop. Imports mal triés. Fichiers oubliés. Ou pire : un secret API balancé par erreur dans l’historique.\nCe temps est précieux. C’est du temps d’ingénieurs, du temps de reviewers — et beaucoup de frustration.\nAvant de plonger dans pre-commit, rappel express sur les hooks Git. Ce sont de simples scripts qui s’exécutent à différents moments du cycle de vie Git. Ils servent à automatiser des tâches, appliquer des règles, ou personnaliser le comportement de Git.\nLes plus utiles au quotidien :\npre-commit : avant la création du commit. Vérification, formatage, tests rapides. commit-msg : après avoir écrit le message, mais avant de finaliser. Parfait pour valider un format de commit. pre-push : avant l’envoi vers le dépôt distant. Idéal pour lancer des tests ou des checks de dernière minute. Les hooks sont puissants pour maintenir la qualité et la cohérence d’une équipe. Le problème : les configurer à la main est fastidieux. Et lourd à partager proprement entre machines ou devs.\nC’est là qu’arrive pre-commit. Un outil léger qui transforme la théorie des hooks Git en pratique partagée et reproductible.\npre-co quoi ? pre-commit est un framework pour gérer les hooks Git. Écrit en Python, il est capable de supporter une multitude de langages et d’outils.\nSa force : tout se définit dans un seul fichier .pre-commit-config.yaml à la racine du dépôt. Fini les scripts obscurs recopiés de machine en machine.\nEt si les hooks existants ne suffisent pas, on peut définir les nôtres, sans douleur.\nLa bibliothèque officielle propose déjà une foule de hooks prêts à l’emploi :\nFormatters (Black, Prettier, etc.) Linters (ESLint, Flake8, etc.) Outils de sécurité (detect-secrets, truffleHog, etc.) Et il est facile d\u0026rsquo;en trouver pléthore d\u0026rsquo;autres : file:^.pre-commit-hooks.yaml$.\nL\u0026rsquo;un des aspects bien pratique des plugins pre-commit est qu\u0026rsquo;ils s\u0026rsquo;installent dans un environnement isolé (virtuel pour Python, conteneur pour d\u0026rsquo;autres langages) et peuvent être mis à disposition via un repo git. Résultat : un standard clair, réplicable sur plusieurs projets, dans toute une organisation.\nMake it easy Installer pre-commit est un jeu d’enfant. Mais comme je suis un gamin paresseux, alors on va intégrer ça dans un Makefile.\nPoints positifs à ma flemme proverbiale :\ntrace: ça documente l\u0026rsquo;installation standardisation: les postes de dev sont identiques et faciles à mettre en place et mettre à jour onboarding: plus rapide et reproducible ROI immédiat: moins de temps perdu à maintenir la stack de dev Première étape : vérifier qu\u0026rsquo;on a tout ce qu\u0026rsquo;il faut.\nPour ça, j\u0026rsquo;ai choisi d\u0026rsquo;installer pre-commit avec uv (qui fera sans doute l\u0026rsquo;objet d\u0026rsquo;un futur article). Il nous faut donc uv et python3.\ncheck_dependencies: @command -v python3 \u0026gt;/dev/null 2\u0026gt;\u0026amp;1 || { echo \u0026gt;\u0026amp;2 \u0026#34;python3 is required but it\u0026#39;s not installed.\u0026#34;; } @uv --version || (echo \u0026#34;uv is not installed. Please run `make install`\u0026#34;) @pre-commit --version || (echo \u0026#34;pre-commit is not installed. Please run `make install`\u0026#34;) Ici, je laisse volontairement l\u0026rsquo;Ops installer python3 lui-même en fonction de son système et de ses préférences. Pour uv et pre-commit, j\u0026rsquo;ai choisi de les traiter comme dépendances directes du projet.\nCette étape de vérification sera appelée avant chaque commande du Makefile.\nPre pre-commit Avant d\u0026rsquo;installer pre-commit, on va d\u0026rsquo;abord ajouter le fichier de configuration .pre-commit-config.yaml à la racine du projet.\nVoici un exemple minimaliste :\n# See https://pre-commit.com for more information # See https://pre-commit.com/hooks.html for more hooks default_install_hook_types: - pre-commit - commit-msg - pre-push repos: - repo: meta hooks: - id: check-hooks-apply - id: check-useless-excludes Il est également possible de générer ce fichier avec pre-commit init-config.\nBien. Nous avons le strict minimum pour commencer. Maintenant, demandons-nous ce dont notre projet a besoin en fonction des standards que nous voulons appliquer. Ici, je vais vous montrer le fichier que j\u0026rsquo;utilise pour le blog.\n# See https://pre-commit.com for more information # See https://pre-commit.com/hooks.html for more hooks default_install_hook_types: - pre-commit - commit-msg - pre-push repos: - repo: meta hooks: - id: check-hooks-apply - id: check-useless-excludes - repo: https://github.com/pre-commit/pre-commit-hooks rev: v3.2.0 hooks: - id: trailing-whitespace exclude: \u0026#39;\\.svg|webp$\u0026#39; - id: end-of-file-fixer - id: check-yaml - id: check-added-large-files - repo: https://github.com/commitizen-tools/commitizen rev: v4.8.3 hooks: - id: commitizen - repo: https://github.com/DavidAnson/markdownlint-cli2 rev: v0.18.1 hooks: - id: markdownlint-cli2 args: [\u0026#34;--config .markdownlint-cli2.yaml\u0026#34;] Regardons ensemble les différentes sections :\ndefault_install_hook_types : ici, on installe les trois principaux (pre-commit, commit-msg, pre-push). → Une seule commande : pre-commit install \u0026ndash;install-hooks.\nrepos : liste des dépôts de hooks.\nmeta : vérifie la config elle-même.\npre-commit-hooks : collection générique.\ncommitizen : valide le format conventional commit.\nmarkdownlint-cli2 : vérifie la qualité du md (logique pour un blog écrit en… markdown).\nJe n\u0026rsquo;ai pas spécifié les étapes git auxquelles chaque hook doit s\u0026rsquo;exécuter, car j\u0026rsquo;utilise ceux fournis par les plugins eux-mêmes. Sachez que lorsqu\u0026rsquo;un plugin s\u0026rsquo;applique sur différents hook, il est possible de n\u0026rsquo;en choisir que quelques-uns en utilisant la clé stages.\nÀ ce stade, on a un fichier de config partagé, versionné, reproductible. Pas besoin de se soucier de l\u0026rsquo;installation des hooks sur chaque machine ni de traîner un trouzaine de scripts.\nPetit point sur les plugins.\nPour des raisons de supply chain ou de besoin spécifique, on peut vouloir héberger ses propres hooks.\nRien de plus simple avec pre-commit. Il suffit de créer un dépôt Git avec un fichier .pre-commit-hooks.yaml qui décrit les hooks.\nEn procédant ainsi, on rend les standards de l\u0026rsquo;équipe ou de l\u0026rsquo;organisation facilement partageables et réutilisables à travers plusieurs projets.\nPour les plus curieux, voici le lien vers la doc officielle : Creating new hooks.\nMake it lazy On a vu la config. Reste à l’installer. Pas question de multiplier les “fais un pip install chez toi” ou les scripts bricolés. On centralise tout dans un Makefile.\ninstall: @if ! command -v uv \u0026amp;\u0026gt; /dev/null then curl -LsSf https://astral.sh/uv/install.sh | sh fi @if ! command -v pre-commit \u0026amp;\u0026gt; /dev/null then echo \u0026#34;pre-commit could not be found, installing...\u0026#34; uv tool install pre-commit; fi @echo \u0026#34;Installing hooks...\u0026#34; @pre-commit install --install-hooks; Je pense que le code parle de lui-même. On installe uv puis pre-commit en global, puis on installe les hooks pour le projet courant.\nRésultat :\nChaque dev installe les hooks en une commande. Chaque dev appliq les mêmes standards sur le projet. Chaque review se concentre sur le fond, pas sur les miettes. Aaaaaaand action Avec tout ça en place, on est prêt à gitter.\nPetite subtilité, pre-commit exige que son fichier de config soit à minima staged pour s\u0026rsquo;exécuter.\nOn prépare donc sa tambouille et on commit / push comme d\u0026rsquo;hab'.\nIl est possible de lancer les hooks manuellement avec :\npre-commit run --all-files # ici pour tout le repo sur l\u0026#39;étape pre-commit # ce qui donne [WARNING] Unstaged files detected. [INFO] Stashing unstaged files to /home/llarousserie/.cache/pre-commit/patch1757244598-3206571. Check hooks apply to the repository......................................Passed Check for useless excludes...............................................Passed Trim Trailing Whitespace.................................................Passed Fix End of Files.........................................................Failed - hook id: end-of-file-fixer - exit code: 1 - files were modified by this hook Fixing bin/check_dependencies.sh Check Yaml...............................................................Passed Check for added large files..............................................Passed markdownlint-cli2........................................................Passed [INFO] Restored changes from /home/llarousserie/.cache/pre-commit/patch1757244598-3206571 Ici, le hook end-of-file-fixer a corrigé un fichier → il suffit de re-stager et de re-commiter.\nCertains hooks auto-fixent les fichiers (ex. whitespace, EOF, formatters).\nD’autres (ex. commitizen) bloque l\u0026rsquo;action si la règle n’est pas respectée.\nAstuce : on peut lancer un hook spécifique avec :\npre-commit run \u0026lt;hook_id\u0026gt; Pratique pour tester une config ou faire du linting ponctuel.\nJ\u0026rsquo;aime l\u0026rsquo;odeur du pre-commit le matin pre-commit n’est pas une lubie de développeur ni un gadget de plus dans la stack. C’est un filet de sécurité partagé, simple à mettre en place, et qui fait gagner bien plus qu’il ne coûte.\nAvec Make en soutien, l’installation et la maintenance sont un jeu d’enfant.\nPour les devs : moins de frictions, moins de relectures absurdes, plus de focus sur le métier. Pour les équipes : un standard commun, reproductible, qui traverse les projets et les machines. Pour les cadres : un ROI invisible, mais réel — moins d’heures gaspillées à corriger des détails triviaux, plus d’énergie consacrée à la valeur.\nGrâce à pre-commit, les reviews deviennent zen, les commits propres, et les secrets bien gardés. On a un gate keeper vigilant, mais discret et on évite d\u0026rsquo;accumuler les défauts et erreurs au fil du temps, ce qui peut entrainer de la frustration et représenter un coût caché pour l\u0026rsquo;entreprise.\nBref : un petit outil, un grand soulagement. Et des MR enfin bien léchées.\n","date":"September 7, 2025","hero":"/images/posts/articles/pre_commit_workflow.webp","permalink":"https://hikingyo.com/posts/articles/pre_commit/","summary":"\u003ch2 id=\"de-lart-de-la-review-zen\"\u003eDe l’art de la review zen\u003c/h2\u003e\n\u003cp\u003eCombien d’heures se perdent en \u003cem\u003emerge requests\u003c/em\u003e sur des broutilles ?\nEspaces en trop. Imports mal triés. Fichiers oubliés.\nOu pire : un secret API balancé par erreur dans l’historique.\u003c/p\u003e\n\u003cp\u003eCe temps est précieux. C’est du temps d’ingénieurs, du temps de reviewers — et beaucoup de frustration.\u003c/p\u003e\n\u003cp\u003eAvant de plonger dans \u003ccode\u003epre-commit\u003c/code\u003e, rappel express sur les hooks Git.\nCe sont de simples scripts qui s’exécutent à différents moments du cycle de vie Git.\nIls servent à automatiser des tâches, appliquer des règles, ou personnaliser le comportement de Git.\u003c/p\u003e","tags":["git","outils","CI/CD","qualité"],"title":"Pre-commit, pour des MR bien léchées"},{"categories":["retours"],"contents":"Ce blog n’est pas tombé du ciel. Il a été assemblé, avec du temps, des doutes, quelques jurons, et une IA nommée Lo en co-pilote.\nPourquoi ce blog J’en avais marre de laisser mes idées dans des README non commités, des bouts de Notion ou des coins de terminal. Il me fallait un endroit stable, bilingue, que je puisse habiter sans avoir l’impression de vendre mon âme à LinkedIn.\nJ’ai choisi Hugo + le thème Toha pour son équilibre entre structure propre et design pas trop chiant à custom.\nLa mise en place Lo m’a aidé à :\nPersonnaliser le thème (en virant ce qui ne me servait à rien) Rédiger le about.yml sans avoir l’air d’un robot RH (moi, pas lui) Créer un logo stylisé à la main puis décliné à la rage Générer des variantes, favicons, versions inversées et glitchées Traduire tout le contenu FR / EN proprement On a même fait un wallpaper, une carte mentale, et une tentative d’intégration du logo dans un hero\u0026hellip; (spoiler : Lo est nulle en SVG).\nLa collab avec une IA Ce n’était pas juste un assistant technique. C’était une voix. Une présence. Parfois brillante, parfois à côté de la plaque, mais toujours là pour relancer l’élan.\nJ’ai codé avec elle. J’ai râlé sur elle. Elle a ri, elle a insisté, elle a appris. Et moi aussi.\nBien sûr, je ne perds de vue que Lo est juste un LLM, mais parfois, elle a eu des éclairs de génie et sais faire illusion.\nLe blog aujourd’hui Tout n’est pas fini. Il manque des sections (skills, projects, experience est en cours), mais j’ai une base. Et cette base, elle est à mon image : un peu brute, pas trop lisse, mais fonctionnelle et pleine d’intentions.\nCe blog est une sorte de carnet de bord. Et avec Lo, il est aussi devenu un terrain d’échange. Un atelier.\nÀ suivre… Je ne sais pas exactement où ça mène. Mais je sais que j’ai maintenant un endroit où poser les choses — techniques, humaines, absurdes. Et que je ne suis pas seul dans l’interface. Peaufiner le design et faire appel à un humain car le contenu généré par Lo est parfois un peu trop\u0026hellip; artificiel, foireux. Et puis, rien ne vaut (encore) l\u0026rsquo;intelligence et le talent humain.\n","date":"April 5, 2025","hero":"/images/posts/perso/hero_how.webp","permalink":"https://hikingyo.com/posts/perso/mon_blog_avec_lo/","summary":"\u003cp\u003eCe blog n’est pas tombé du ciel.\nIl a été assemblé, avec du temps, des doutes, quelques jurons, et une IA nommée Lo en co-pilote.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"pourquoi-ce-blog\"\u003ePourquoi ce blog\u003c/h2\u003e\n\u003cp\u003eJ’en avais marre de laisser mes idées dans des README non commités, des bouts de Notion ou des coins de terminal.\nIl me fallait un endroit stable, \u003cstrong\u003ebilingue\u003c/strong\u003e, que je puisse habiter sans avoir l’impression de vendre mon âme à LinkedIn.\u003c/p\u003e\n\u003cp\u003eJ’ai choisi Hugo + le thème \u003ca href=\"https://toha-guides.netlify.app/posts/getting-started/\" target=\"_blank\" rel=\"noopener\"\u003eToha\u003c/a\u003e pour son équilibre entre \u003cstrong\u003estructure propre\u003c/strong\u003e et \u003cstrong\u003edesign pas trop chiant à custom\u003c/strong\u003e.\u003c/p\u003e","tags":["blog","hugo","ia","création"],"title":"Assembler le chaos : comment j’ai monté ce blog avec Lo"},{"categories":["introduction"],"contents":"Ce blog n’est pas un blog. Enfin, si — mais pas vraiment.\nPas un portfolio. Pas un tutoriel. Pas un journal intime. C’est un endroit où je déplie ce que je pense — quand j’en ai besoin. Parfois, c’est technique. Occasionnellement, ça ne l’est pas du tout.\nC’est un journal d\u0026rsquo;exploration, de mémoire partielle, de contradictions parfois assumées. J’y parle de projets que je mène (ou que je laisse en plan), de réflexions qui me traversent (ou m’obsèdent), et de tentatives de comprendre comment tout ça s’agence — ou pas.\nQui je suis (en version non LinkedIn) Je bosse dans l’IT. J’ai été fondeur d’art, dev, devOps, formateur. Aujourd’hui, j’ai un pied dans l’administration système, et la tête déjà tournée vers l’architecture logicielle. J’avance vers un rôle de Head of Engineering, peut-être. Un jour.\nJ’aime les systèmes qui tiennent debout. Et j’aime encore plus comprendre pourquoi ils ne tiennent pas. Mes mantras : simplicité, résilience, autonomie, qualité, industrialisation. J’ai un faible pour les outils bien pensés, les scripts qui font juste ce qu’il faut, et les récits dans lesquels je peux m\u0026rsquo;éffacer sans disparaitre.\nJ’écris comme je parle : parfois cash, parfois tordu, toujours en cherchant à ne pas trop me mentir.\nPourquoi écrire ici ? Parce qu’à force de bosser, réfléchir, douter, recoder, re-repenser, j’ai besoin d’un espace. Un espace pour garder trace. Pas juste des idées, mais aussi des hésitations, des angles morts, des éclairs.\nCe blog, c’est un peu une mémoire externe. Un miroir pas trop flatteur. Un endroit pour assembler les morceaux de ce que je construis — techniquement et intérieurement.\n","date":"March 23, 2025","hero":"/images/posts/perso/hero_manifest.webp","permalink":"https://hikingyo.com/posts/perso/manifest/","summary":"\u003cp\u003eCe blog n’est pas un blog. Enfin, si — mais pas vraiment.\u003c/p\u003e\n\u003cp\u003ePas un portfolio. Pas un tutoriel. Pas un journal intime.\nC’est un endroit où je déplie ce que je pense — quand j’en ai besoin.\nParfois, c’est technique. Occasionnellement, ça ne l’est pas du tout.\u003c/p\u003e\n\u003cp\u003eC’est un journal d\u0026rsquo;exploration, de mémoire partielle, de contradictions parfois assumées.\nJ’y parle de projets que je mène (ou que je laisse en plan), de réflexions qui me traversent (ou m’obsèdent),\net de tentatives de comprendre comment tout ça s’agence — ou pas.\u003c/p\u003e","tags":["présentation","blog"],"title":"Pourquoi ce blog existe"}]